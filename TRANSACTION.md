# **서비스 확장에 따른 트랜잭션 처리 한계와 해결 방안**

## 1. 요약

본 문서는 MSA(Microservices Architecture) 환경에서 트랜잭션 처리의 한계를 분석하고, 이를 해결하기 위한 전략으로 **SAGA 패턴, 이벤트 기반 아키텍처, Redis 기반 분산 잠금** 등의 방안을 제시합니다. 각 전략은 서비스 간의 트랜잭션 일관성을 유지하며 성능과 확장성을 고려하여 실제 서비스 시나리오에 맞게 적용될 수 있도록 분석됩니다.

---

## 2. 서론

### 2.1 연구 배경

서비스가 **단일 모놀리식(monolithic)** 아키텍처에서 **MSA**로 확장됨에 따라, 각 서비스는 독립적인 데이터베이스를 가지게 됩니다. 이로 인해 기존의 **ACID 트랜잭션** 모델이 적용되지 않으며, 분산 트랜잭션 관리가 필요해졌습니다.

MSA 환경에서는 서비스 간 **네트워크 지연, 장애, 부분 실패** 등이 발생할 수 있으며, 이러한 상황에서 일관성 있는 트랜잭션 관리는 중요한 과제로 떠오릅니다.

### 2.2 문제 정의

- **서비스 간 트랜잭션 일관성 유지가 어려움**
- **네트워크 장애나 개별 서비스 장애**로 인한 데이터 불일치 가능성
- **동시성 문제**로 인한 재고 관리, 결제 처리, 쿠폰 사용 등에서 충돌 발생

이에 대한 해결 방안으로 **SAGA 패턴**, **이벤트 기반 아키텍처**, **Redis 분산 잠금** 등을 적용할 수 있습니다.

---

## 3. 연구 방법

이 연구에서는 MSA 환경에서 발생할 수 있는 트랜잭션 문제를 해결하기 위한 다양한 전략을 분석하고, 각 전략을 실제 서비스 시나리오에 어떻게 적용할 수 있는지 평가합니다. 특히, **SAGA 패턴**, **이벤트 기반 아키텍처**, **분산 잠금 처리**를 중점적으로 다룹니다.

---

## 4. 연구 결과

### 4.1 SAGA 패턴 (보상 트랜잭션)

**SAGA 패턴**은 분산 트랜잭션을 관리하는 대표적인 방법으로, 서비스 간의 트랜잭션을 **보상 트랜잭션**을 통해 롤백하는 방식입니다.

### ✅ 적용 가능 시나리오

1. **결제 생성 및 사용자 잔액 차감 처리**
    - **결제 서비스**에서 결제 요청을 생성하고, **사용자 서비스**에서 잔액 차감을 수행합니다.
    - 잔액 차감 실패 시, 결제 상태를 '결제 실패'로 변경하고 사용자에게 알림을 전송합니다.
2. **쿠폰 사용 시 주문 가격 할인 처리**
    - **주문 서비스**에서 주문 요청을 생성하고, **쿠폰 서비스**에서 쿠폰 검증 및 사용 처리를 수행합니다.
    - 쿠폰 사용이 실패하면 주문 상태를 '쿠폰 사용 실패'로 변경합니다.

### 🛠 **Redis 기반 잠금과 SAGA 통합**

Redis 기반 분산 잠금은 **SAGA 패턴의 보상 트랜잭션** 내에서 **동시성 문제**를 해결하는 데 중요한 역할을 합니다. 특히 **상품 재고 차감 시 동시 요청을 방지**하기 위해 Redis `SETNX`(SET if Not Exists)를 사용하여 잠금을 관리합니다.

**적용 예시:**

```java
String lockKey = "lock:product:123";
boolean isLocked = redisTemplate.opsForValue().setIfAbsent(lockKey, "LOCKED", Duration.ofSeconds(10));
if (isLocked) {
    try {
        // 재고 차감 로직 수행
    } finally {
        redisTemplate.delete(lockKey); // 락 해제
    }
}

```

---

### 4.2 이벤트 기반 아키텍처

**이벤트 기반 아키텍처**는 서비스 간의 강한 결합도를 줄이기 위해 **비동기 이벤트 메시징**을 활용하여 트랜잭션을 관리하는 방식입니다. 이를 통해 서비스들은 서로 독립적으로 동작하며, 이벤트 큐를 통해 데이터 일관성을 유지할 수 있습니다.

### ✅ 적용 가능 시나리오

1. **결제 상태 업데이트 후 주문 상태 업데이트**
    - **결제 서비스**가 '결제 완료' 이벤트를 발행하고, **주문 서비스**가 이를 구독하여 주문 상태를 업데이트합니다.
2. **쿠폰 발급 요청에 대한 성공/실패 사용자 알림**
    - **쿠폰 서비스**가 쿠폰 발급 성공/실패 이벤트를 발행하고, **알림 서비스**가 이를 구독하여 사용자에게 알림을 전송합니다.
3. **결제 성공 시 일일 판매량 업데이트**
    - **결제 완료 이벤트**를 발행하고, **상품 서비스**가 이를 구독하여 일일 판매량을 업데이트합니다.
4. **결제 성공 시 데이터 플랫폼에 주문 정보 전달**
    - **결제 서비스**가 '주문 정보 이벤트'를 발행하고, **데이터 플랫폼 서비스**가 이를 구독하여 분석 데이터를 생성합니다.

---

## 5. 결론

MSA 환경에서 트랜잭션을 안정적으로 관리하기 위한 최적의 전략은 **SAGA 패턴**, **이벤트 기반 아키텍처**, **Redis 기반 분산 잠금**의 조합입니다.

### 결론적으로:

- **SAGA 패턴**은 결제 및 사용자 잔액 차감, 쿠폰 사용과 같은 트랜잭션에 유용하게 적용될 수 있습니다.
- **이벤트 기반 아키텍처**는 결제 상태 업데이트, 쿠폰 발급 알림, 데이터 플랫폼에 주문 정보 전달 등의 시나리오에서 유리합니다.
- **Redis 분산 잠금**은 주문 생성 시 상품 재고 차감에서 동시성 문제를 해결할 수 있습니다.

이러한 전략을 조합함으로써 **MSA 환경에서 서비스 간 트랜잭션 정합성을 유지**하면서도 **확장성과 성능을 고려한 안정적인 시스템**을 구축할 수 있습니다.